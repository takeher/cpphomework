main.cpp:
对链表做排序。使用归并排序得到O(1)的空间复杂度。
这里采用自底向上的归并排序法。
首先求得链表的长度length，然后将链表拆分成子链表进行合并。
具体做法如下。
用subLength表示每次需要排序的子链表的长度，初始时subLength=1。
每次将链表拆分成若干个长度为subLength的子链表
（最后一个子链表的长度可以小于subLength），
按照每两个子链表一组进行合并，
合并后即可得到若干个长度为subLength×2的有序子链表
（最后一个子链表的长度可以小于subLength×2）。
合并两个子链表仍然使用「合并两个有序链表」的做法。
将subLength的值加倍，重复第 2 步，
对更长的有序子链表进行合并操作，
直到有序子链表的长度大于或等于length，整个链表排序完毕。
如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。
1.初始时subLength=1，每个长度为1的子链表都是有序的。
2.如果每个长度为subLength的子链表已经有序，
  合并两个长度为subLength的有序子链表，
  得到长度为subLength×2的子链表，一定也是有序的。
3.当最后一个子链表的长度小于subLength时，该子链表也是有序的，
  合并两个有序子链表之后得到的子链表一定也是有序的。
因此可以保证最后得到的链表是有序的。

